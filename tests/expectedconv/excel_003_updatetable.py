# -*- coding: utf-8 -*-

"""This file was auto-generated by PyFlow exporter
    'Python exporter v1.0.0'
    Created: 10:57AM on October 02, 2025
"""

EXPORTER_NAME = 'Python exporter'
EXPORTER_VERSION = '1.0.0'


# ======================== VARIABLES AND PARAMETERS SETUP =========================
VARS = {}


# ================================ PACKAGE IMPORTS ================================
# pylint: disable=wrong-import-position
import xlwings as xw
import pandas as pd
import re
from pandasql.sqldf import (extract_table_names,
                            write_table,
                            get_outer_frame_variables,
                            PandaSQLException,
                            PandaSQL as pSQL)
from sqlalchemy.exc import (DatabaseError,
                            ResourceClosedError)
from typing import (cast)
# pylint: enable=wrong-import-position

# ================================= PACKAGE SETUPS ================================
class PandaSQL(pSQL):
    """A patched subclass of PandaSQL providing parameterized queries against Pandas DataFrames"""

    @staticmethod
    def sql_power(x: float, y: float) -> float | None:
        """UDF to return x to the power of y"""
        try:
            return x**y
        except:
            return None

    def _init_connection(self, conn):
        if self.engine.name == 'sqlite':
            conn.connection.driver_connection.create_function(
                'power', 2, self.sql_power)
        super()._init_connection(conn)

    def __call__(self, query, env=None, params=None):
        """
        Execute the SQL query.
        Automatically creates tables mentioned in the query from dataframes before executing.

        :param query: SQL query string, which can reference pandas dataframes as SQL tables.
        :param env: Variables environment - a dict mapping table names to pandas dataframes.
        If not specified use local and global variables of the caller.
        :return: Pandas dataframe with the result of the SQL query.
        """
        if env is None:
            env = get_outer_frame_variables()

        result = None

        with self.conn as conn:
            for table_name in extract_table_names(query):
                if table_name not in env:
                    # don't raise error because the table may be already in the database
                    continue
                if self.persist and table_name in self.loaded_tables:
                    # table was loaded before using the same instance, don't do it again
                    continue
                if isinstance(env[table_name], pd.DataFrame):
                    self.loaded_tables.add(table_name)
                    write_table(env[table_name], table_name, conn)

            try:
                result = pd.read_sql(query, conn, params=params)
            except DatabaseError as ex:
                raise PandaSQLException(ex) from ex
            except ResourceClosedError:
                # query returns nothing
                result = None

        return result

    @staticmethod
    def uniquify(df_columns) -> list[str]:
        """Make a list of columns unique"""
        seen = set()
        result = []
        for item in df_columns:
            fudge = 1
            newitem = item

            while newitem in seen:
                fudge += 1
                newitem = f"{item}_{fudge}"

            result.append(newitem)
            seen.add(newitem)
        return result


# ================================ SYSTEM FUNCTIONS ===============================
def openExcel(path):
    """Open an Excel file with xlwings"""
    return xw.Book(path, update_links=False)


def loadExcelRange(book, sheet_name, range_name, num_header_rows, index, expand):
    """Reads an Excel Range of which top-left cell or whole range
    is given and returns the data as a Pandas DataFrame"""
    if book is None:
        return None
    sh: xw.Sheet = book.sheets[sheet_name]
    if range_name and range_name not in ['None', 'UsedRange']:
        rng = sh.range(range_name)
    else:
        rng = sh.used_range
    if expand=='':
        expand=None
    return rng.options(pd.DataFrame, header=num_header_rows, index=index, expand=expand).value


def queryPandas(sql, tables, params):
    psql = PandaSQL(persist=True)

    sqlstatements = [s
                        for s in sql.split(';\n')
                        if not re.search(r"^[;\s]*$", s)]
    results = []

    for sqlstatement in sqlstatements:
        res = psql(sqlstatement, tables, params=params)  # type: ignore
        if res is not None:
            res.columns = psql.uniquify(res.columns)
            results.append(res)

    if len(results)==0:
        return None
    if len(results)==1:
        return results[0]
    return results


def updateExcelTable(wb: xw.Book | None,
                     sheet_name: str,
                     table_name: str,
                     data: pd.DataFrame,
                     index: bool):
    """Updates an Excel Table object with new data given as a Pandas DataFrame"""
    if wb is None:
        return
    if sheet_name in wb.sheet_names:
        ws = cast(xw.Sheet, wb.sheets[sheet_name])
        if table_name in [t.name for t in ws.tables]:
            t = cast(xw.main.Table, ws.tables[table_name])
        else:
            t = cast(xw.main.Table, ws.tables.add(source=ws['A1'], name=table_name))
    else:
        ws = cast(xw.Sheet, wb.sheets.add())
        ws.name = sheet_name
        t = cast(xw.main.Table, ws.tables.add(source=ws['A1'], name=table_name))
    t.update(data, index=index)


def loadExcelTable(book, table_name, index):
    """Reads an Excel Table object and returns the data as a Pandas DataFrame"""
    if book is not None:
        for ws in book.sheets:
            for t in ws.tables:
                if t.name==table_name:
                    data = t.range.options(pd.DataFrame, index=index).value
                    return data
    return None


def closeExcel(book):
    """Close an xlwings workbook"""
    if book is not None:
        book.close()




# ============================== GRAPH IMPLEMENTATION =============================


# ================================== MAIN PROGRAM =================================


# ------- OpenExcel_inExec -------
OpenExcel_out = openExcel('tests\\graphs\\test_data.xlsx')
LoadExcelRange_out = loadExcelRange(OpenExcel_out, 'data1', 'A1', 1, False, 'table')
PandasSQLQuery_result = queryPandas("""select *
                                       from data1
                                       where id<=2""",
                                    tables={'data1': LoadExcelRange_out,
                                            },
                                    params={})
updateExcelTable(OpenExcel_out, 'data1', 'tData1', PandasSQLQuery_result, False)
LoadExcelTable_out = loadExcelTable(OpenExcel_out, 'tData1', False)
closeExcel(OpenExcel_out)
print(LoadExcelTable_out)
