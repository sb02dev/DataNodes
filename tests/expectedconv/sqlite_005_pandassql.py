# -*- coding: utf-8 -*-

"""This file was auto-generated by PyFlow exporter
    'Python exporter v1.0.0'
    Created: 09:48PM on October 01, 2025
"""

EXPORTER_NAME = 'Python exporter'
EXPORTER_VERSION = '1.0.0'


# ======================== VARIABLES AND PARAMETERS SETUP =========================
VARS = {}


# ================================ PACKAGE IMPORTS ================================
# pylint: disable=wrong-import-position
from sqlalchemy import (create_engine,
                        text)
import pandas as pd
import re
from pandasql.sqldf import (extract_table_names,
                            write_table,
                            get_outer_frame_variables,
                            PandaSQLException,
                            PandaSQL as pSQL)
from sqlalchemy.exc import (DatabaseError,
                            ResourceClosedError)
# pylint: enable=wrong-import-position

# ================================= PACKAGE SETUPS ================================
class PandaSQL(pSQL):
    """A patched subclass of PandaSQL providing parameterized queries against Pandas DataFrames"""

    @staticmethod
    def sql_power(x: float, y: float) -> float | None:
        """UDF to return x to the power of y"""
        try:
            return x**y
        except:
            return None

    def _init_connection(self, conn):
        if self.engine.name == 'sqlite':
            conn.connection.driver_connection.create_function(
                'power', 2, self.sql_power)
        super()._init_connection(conn)

    def __call__(self, query, env=None, params=None):
        """
        Execute the SQL query.
        Automatically creates tables mentioned in the query from dataframes before executing.

        :param query: SQL query string, which can reference pandas dataframes as SQL tables.
        :param env: Variables environment - a dict mapping table names to pandas dataframes.
        If not specified use local and global variables of the caller.
        :return: Pandas dataframe with the result of the SQL query.
        """
        if env is None:
            env = get_outer_frame_variables()

        result = None

        with self.conn as conn:
            for table_name in extract_table_names(query):
                if table_name not in env:
                    # don't raise error because the table may be already in the database
                    continue
                if self.persist and table_name in self.loaded_tables:
                    # table was loaded before using the same instance, don't do it again
                    continue
                if isinstance(env[table_name], pd.DataFrame):
                    self.loaded_tables.add(table_name)
                    write_table(env[table_name], table_name, conn)

            try:
                result = pd.read_sql(query, conn, params=params)
            except DatabaseError as ex:
                raise PandaSQLException(ex) from ex
            except ResourceClosedError:
                # query returns nothing
                result = None

        return result

    @staticmethod
    def uniquify(df_columns) -> list[str]:
        """Make a list of columns unique"""
        seen = set()
        result = []
        for item in df_columns:
            fudge = 1
            newitem = item

            while newitem in seen:
                fudge += 1
                newitem = f"{item}_{fudge}"

            result.append(newitem)
            seen.add(newitem)
        return result


# ================================ SYSTEM FUNCTIONS ===============================
def connect_genericdb(connection_url):
    """Connect to a generic database according to the connection url"""
    engine = create_engine(connection_url)
    return engine

def queryDatabase(conn, sql, has_result, param_dict={}, **kwargs):
    # tranform parameters
    parameters = {}
    for k, v in kwargs.items():
        if not k in parameters:
            parameters[k] = v
    for k, v in param_dict.items():
        if not k in parameters:
            parameters[k] = v

    # query
    sqlstatements = [s
                     for s in sql.split(';\n')
                     if not re.search(r"^[;\s]*$", s)]
    table = None

    with conn.begin() as active_conn:
        for i, sqlstatement in enumerate(sqlstatements):
            if has_result and i==len(sqlstatements)-1: # only last statement can have result
                table = pd.read_sql_query(text(sqlstatement),
                                            active_conn,
                                            params=parameters)
            else:
                active_conn.execute(text(sqlstatement), parameters)
    
    return table

def queryPandas(sql, tables, params):
    psql = PandaSQL(persist=True)

    sqlstatements = [s
                        for s in sql.split(';\n')
                        if not re.search(r"^[;\s]*$", s)]
    results = []

    for sqlstatement in sqlstatements:
        res = psql(sqlstatement, tables, params=params)  # type: ignore
        if res is not None:
            res.columns = psql.uniquify(res.columns)
            results.append(res)

    if len(results)==0:
        return None
    if len(results)==1:
        return results[0]
    return results




# ============================== GRAPH IMPLEMENTATION =============================


# ================================== MAIN PROGRAM =================================


# ------- GenericDBConn_inExec -------
GenericDBConn_out = connect_genericdb('sqlite:///tests/temp/db.sdb')
SQLQuery_result = queryDatabase(GenericDBConn_out, """select 1 as id, 'aaa' as name
                                                      union all
                                                      select 2 as id, 'bbb' as name""", True)
PandasSQLQuery_result = queryPandas("""select count(*) from tableA""",
                                    tables={'tableA': SQLQuery_result,
                                            },
                                    params={})
print(PandasSQLQuery_result)
